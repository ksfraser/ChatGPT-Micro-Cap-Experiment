"""
Portfolio Manager for Stock Analysis Extension
Manages portfolio operations, risk assessment, and trade execution
"""

import pandas as pd
import numpy as np
from datetime import datetime, timedelta
from typing import Dict, List, Tuple, Optional, Any
import logging
from .database_manager import DatabaseManager
from .stock_data_fetcher import StockDataFetcher
from .stock_analyzer import StockAnalyzer
from .front_accounting import FrontAccountingIntegrator

class PortfolioManager:
    def __init__(self, config: Dict[str, Any]):
        """
        Initialize portfolio manager
        
        Args:
            config: Configuration dictionary
        """
        self.config = config
        self.logger = logging.getLogger(__name__)
        
        # Initialize components
        self.db_manager = DatabaseManager(config['DATABASE_CONFIG'])
        self.data_fetcher = StockDataFetcher(config)
        self.analyzer = StockAnalyzer(config)
        self.fa_integrator = FrontAccountingIntegrator(config)
        
        # Risk management settings
        self.risk_config = config.get('RISK_CONFIG', {})
        self.max_position_size = self.risk_config.get('max_position_size', 0.05)
        self.stop_loss_pct = self.risk_config.get('stop_loss_pct', 0.15)
        self.take_profit_pct = self.risk_config.get('take_profit_pct', 0.25)
        self.max_correlation = self.risk_config.get('max_correlation', 0.7)
        self.max_sector_exposure = self.risk_config.get('max_sector_exposure', 0.25)
        
        self.portfolio_id = 1  # Default portfolio ID
        
    def initialize_system(self) -> Dict[str, Any]:
        """
        Initialize the portfolio management system
        
        Returns:
            Dictionary containing initialization results
        """
        results = {
            'database_connection': False,
            'database_schema': False,
            'frontaccounting_connection': False,
            'data_sources': [],
            'errors': []
        }
        
        try:
            # Test database connection
            if self.db_manager.create_connection():
                results['database_connection'] = True
                
                # Create schema if needed
                if self.db_manager.create_database_schema():
                    results['database_schema'] = True
                else:
                    results['errors'].append("Failed to create database schema")
            else:
                results['errors'].append("Failed to connect to database")
            
            # Test FrontAccounting connection
            fa_test = self.fa_integrator.test_connection()
            if fa_test['status'] == 'success':
                results['frontaccounting_connection'] = True
            else:
                results['errors'].append(f"FrontAccounting connection failed: {fa_test['message']}")
            
            # Test data sources
            test_symbols = ['AAPL', 'MSFT']
            for symbol in test_symbols:
                data = self.data_fetcher.get_stock_data(symbol, period='5d', include_fundamentals=False)
                if not data['price_data'].empty:
                    results['data_sources'].append(data['source'])
                    
            self.logger.info("Portfolio management system initialized successfully")
            
        except Exception as e:
            self.logger.error(f"Error initializing portfolio system: {e}")
            results['errors'].append(str(e))
            
        return results
    
    def analyze_portfolio_stock(self, symbol: str) -> Dict[str, Any]:
        """
        Analyze a stock for potential portfolio inclusion
        
        Args:
            symbol: Stock symbol to analyze
            
        Returns:
            Dictionary containing analysis results
        """
        try:
            # Fetch stock data
            stock_data = self.data_fetcher.get_stock_data(symbol, period='1y', include_fundamentals=True)
            
            if stock_data['price_data'].empty:
                return {
                    'symbol': symbol,
                    'error': f"No data available for {symbol}",
                    'analysis': None
                }
            
            # Perform analysis
            analysis = self.analyzer.analyze_stock(stock_data)
            
            # Store analysis results in database
            if analysis['error'] is None:
                self.db_manager.update_analysis_results(symbol, analysis)
                
                # Store fundamental data
                if stock_data['fundamentals']:
                    self._store_fundamental_data(symbol, stock_data['fundamentals'])
                
                # Store price data (last 30 days to avoid overwhelming database)
                recent_prices = stock_data['price_data'].tail(30).copy()
                if not recent_prices.empty:
                    recent_prices['symbol'] = symbol
                    self.db_manager.insert_stock_data(recent_prices, 'stock_prices')
            
            return {
                'symbol': symbol,
                'error': None,
                'analysis': analysis,
                'stock_data': stock_data
            }
            
        except Exception as e:
            self.logger.error(f"Error analyzing stock {symbol}: {e}")
            return {
                'symbol': symbol,
                'error': str(e),
                'analysis': None
            }
    
    def get_portfolio_recommendations(self, max_recommendations: int = 10) -> List[Dict[str, Any]]:
        """
        Get stock recommendations for portfolio
        
        Args:
            max_recommendations: Maximum number of recommendations
            
        Returns:
            List of recommended stocks
        """
        try:
            # Get S&P 500 stocks for analysis
            sp500_symbols = self.data_fetcher.get_sp500_list()
            
            # Limit analysis to avoid overwhelming the system
            analysis_batch_size = 50
            symbols_to_analyze = sp500_symbols[:analysis_batch_size]
            
            recommendations = []
            
            self.logger.info(f"Analyzing {len(symbols_to_analyze)} stocks for recommendations")
            
            # Analyze stocks in batches
            for i in range(0, len(symbols_to_analyze), 10):
                batch = symbols_to_analyze[i:i+10]
                
                for symbol in batch:
                    try:
                        result = self.analyze_portfolio_stock(symbol)
                        
                        if result['error'] is None and result['analysis']:
                            analysis = result['analysis']
                            
                            # Filter by minimum score
                            if analysis['overall_score'] >= 65 and analysis['recommendation'] in ['BUY', 'STRONG_BUY']:
                                recommendations.append({
                                    'symbol': symbol,
                                    'score': analysis['overall_score'],
                                    'recommendation': analysis['recommendation'],
                                    'target_price': analysis['target_price'],
                                    'current_price': result['stock_data']['price_data']['close'].iloc[-1],
                                    'risk_rating': analysis['risk_rating'],
                                    'confidence': analysis['confidence_level'],
                                    'fundamental_score': analysis['fundamental_score'],
                                    'technical_score': analysis['technical_score'],
                                    'company_name': result['stock_data']['fundamentals'].get('company_name', symbol),
                                    'sector': result['stock_data']['fundamentals'].get('sector', 'Unknown')
                                })
                                
                    except Exception as e:
                        self.logger.warning(f"Error analyzing {symbol}: {e}")
                        continue
            
            # Sort by score and return top recommendations
            recommendations.sort(key=lambda x: x['score'], reverse=True)
            
            # Apply risk management filters
            filtered_recommendations = self._apply_risk_filters(recommendations)
            
            return filtered_recommendations[:max_recommendations]
            
        except Exception as e:
            self.logger.error(f"Error getting portfolio recommendations: {e}")
            return []
    
    def _apply_risk_filters(self, recommendations: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        Apply risk management filters to recommendations
        
        Args:
            recommendations: List of stock recommendations
            
        Returns:
            Filtered list of recommendations
        """
        try:
            # Get current portfolio
            current_positions = self.db_manager.get_portfolio_positions(self.portfolio_id)
            
            filtered_recommendations = []
            sector_exposure = {}
            
            # Calculate current sector exposure
            if not current_positions.empty:
                total_portfolio_value = current_positions['position_value'].sum()
                
                for _, position in current_positions.iterrows():
                    sector = position.get('sector', 'Unknown')
                    sector_exposure[sector] = sector_exposure.get(sector, 0) + (
                        position['position_value'] / total_portfolio_value
                    )
            
            for rec in recommendations:
                # Check sector exposure limits
                sector = rec['sector']
                current_sector_exposure = sector_exposure.get(sector, 0)
                
                if current_sector_exposure >= self.max_sector_exposure:
                    self.logger.info(f"Skipping {rec['symbol']} - sector {sector} exposure limit reached")
                    continue
                
                # Check if already in portfolio
                if not current_positions.empty:
                    existing_position = current_positions[current_positions['symbol'] == rec['symbol']]
                    if not existing_position.empty:
                        self.logger.info(f"Skipping {rec['symbol']} - already in portfolio")
                        continue
                
                # Check risk rating
                if rec['risk_rating'] in ['VERY_HIGH']:
                    self.logger.info(f"Skipping {rec['symbol']} - risk rating too high")
                    continue
                
                filtered_recommendations.append(rec)
                
                # Update sector exposure for next iteration
                sector_exposure[sector] = current_sector_exposure + self.max_position_size
            
            return filtered_recommendations
            
        except Exception as e:
            self.logger.warning(f"Error applying risk filters: {e}")
            return recommendations
    
    def calculate_position_size(self, symbol: str, target_price: float, portfolio_value: float) -> Dict[str, Any]:
        """
        Calculate appropriate position size for a stock
        
        Args:
            symbol: Stock symbol
            target_price: Target purchase price
            portfolio_value: Current portfolio value
            
        Returns:
            Dictionary containing position size calculations
        """
        try:
            # Get stock analysis for risk assessment
            analysis_data = self.db_manager.get_top_recommendations(limit=1000)
            stock_analysis = analysis_data[analysis_data['symbol'] == symbol]
            
            if stock_analysis.empty:
                risk_multiplier = 0.5  # Conservative if no analysis
            else:
                risk_rating = stock_analysis.iloc[0]['risk_rating']
                risk_multipliers = {
                    'LOW': 1.0,
                    'MEDIUM': 0.8,
                    'HIGH': 0.6,
                    'VERY_HIGH': 0.4
                }
                risk_multiplier = risk_multipliers.get(risk_rating, 0.5)
            
            # Calculate base position size
            base_position_value = portfolio_value * self.max_position_size * risk_multiplier
            
            # Calculate number of shares
            shares = int(base_position_value / target_price)
            actual_position_value = shares * target_price
            actual_position_pct = actual_position_value / portfolio_value
            
            # Calculate stop loss and take profit levels
            stop_loss_price = target_price * (1 - self.stop_loss_pct)
            take_profit_price = target_price * (1 + self.take_profit_pct)
            
            return {
                'symbol': symbol,
                'recommended_shares': shares,
                'position_value': actual_position_value,
                'position_percentage': actual_position_pct * 100,
                'target_price': target_price,
                'stop_loss_price': round(stop_loss_price, 2),
                'take_profit_price': round(take_profit_price, 2),
                'risk_multiplier': risk_multiplier,
                'max_loss': actual_position_value * self.stop_loss_pct
            }
            
        except Exception as e:
            self.logger.error(f"Error calculating position size for {symbol}: {e}")
            return {
                'symbol': symbol,
                'recommended_shares': 0,
                'position_value': 0,
                'position_percentage': 0,
                'error': str(e)
            }
    
    def execute_trade(self, trade_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Execute a trade and update all systems
        
        Args:
            trade_data: Trade information
            
        Returns:
            Dictionary containing execution results
        """
        try:
            symbol = trade_data['symbol']
            trade_type = trade_data['trade_type'].upper()
            quantity = float(trade_data['quantity'])
            price = float(trade_data['price'])
            total_amount = quantity * price
            
            # Validate trade
            validation_result = self._validate_trade(trade_data)
            if not validation_result['valid']:
                return {
                    'status': 'error',
                    'message': validation_result['message'],
                    'trade_id': None
                }
            
            # Prepare trade data for database
            db_trade_data = {
                'portfolio_id': self.portfolio_id,
                'symbol': symbol,
                'trade_type': trade_type,
                'quantity': quantity,
                'price': price,
                'total_amount': total_amount,
                'trade_date': trade_data.get('trade_date', datetime.now()),
                'strategy': trade_data.get('strategy', 'Manual'),
                'notes': trade_data.get('notes', '')
            }
            
            # Log trade to database
            trade_logged = self.db_manager.log_trade_transaction(db_trade_data)
            
            if not trade_logged:
                return {
                    'status': 'error',
                    'message': 'Failed to log trade to database',
                    'trade_id': None
                }
            
            # Update portfolio positions
            position_updated = self._update_portfolio_position(trade_data)
            
            if not position_updated:
                return {
                    'status': 'error',
                    'message': 'Failed to update portfolio position',
                    'trade_id': None
                }
            
            # Sync to FrontAccounting
            fa_result = self.fa_integrator.sync_trade_to_fa(None, db_trade_data)  # Trade ID would come from DB
            
            result = {
                'status': 'success',
                'message': f'{trade_type} order executed for {quantity} shares of {symbol} at ${price:.2f}',
                'trade_id': None,  # Would be populated from database
                'total_amount': total_amount,
                'fa_sync_status': fa_result['status'],
                'fa_transaction_id': fa_result.get('fa_transaction_id')
            }
            
            self.logger.info(f"Trade executed: {result['message']}")
            return result
            
        except Exception as e:
            self.logger.error(f"Error executing trade: {e}")
            return {
                'status': 'error',
                'message': str(e),
                'trade_id': None
            }
    
    def _validate_trade(self, trade_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Validate trade before execution
        
        Args:
            trade_data: Trade information
            
        Returns:
            Dictionary containing validation results
        """
        try:
            symbol = trade_data['symbol']
            trade_type = trade_data['trade_type'].upper()
            quantity = float(trade_data['quantity'])
            price = float(trade_data['price'])
            
            # Get current portfolio
            positions = self.db_manager.get_portfolio_positions(self.portfolio_id)
            
            if trade_type == 'BUY':
                # Check if we have enough cash
                total_cost = quantity * price
                # This would need to be implemented based on your cash tracking
                # For now, assume validation passes
                pass
                
            elif trade_type == 'SELL':
                # Check if we have enough shares
                if not positions.empty:
                    existing_position = positions[positions['symbol'] == symbol]
                    if existing_position.empty:
                        return {
                            'valid': False,
                            'message': f'No position found for {symbol}'
                        }
                    
                    current_quantity = existing_position.iloc[0]['quantity']
                    if quantity > current_quantity:
                        return {
                            'valid': False,
                            'message': f'Insufficient shares: have {current_quantity}, trying to sell {quantity}'
                        }
                else:
                    return {
                        'valid': False,
                        'message': f'No positions in portfolio'
                    }
            
            return {
                'valid': True,
                'message': 'Trade validation passed'
            }
            
        except Exception as e:
            return {
                'valid': False,
                'message': f'Validation error: {str(e)}'
            }
    
    def _update_portfolio_position(self, trade_data: Dict[str, Any]) -> bool:
        """
        Update portfolio position after trade execution
        
        Args:
            trade_data: Trade information
            
        Returns:
            Boolean indicating success
        """
        try:
            # This would implement the position update logic
            # For now, returning True as placeholder
            return True
            
        except Exception as e:
            self.logger.error(f"Error updating portfolio position: {e}")
            return False
    
    def _store_fundamental_data(self, symbol: str, fundamentals: Dict[str, Any]):
        """
        Store fundamental data in database
        
        Args:
            symbol: Stock symbol
            fundamentals: Fundamental data dictionary
        """
        try:
            # Prepare fundamental data for database
            fund_data = pd.DataFrame([{
                'symbol': symbol,
                'company_name': fundamentals.get('company_name'),
                'sector': fundamentals.get('sector'),
                'industry': fundamentals.get('industry'),
                'market_cap': fundamentals.get('market_cap'),
                'pe_ratio': fundamentals.get('pe_ratio'),
                'forward_pe': fundamentals.get('forward_pe'),
                'peg_ratio': fundamentals.get('peg_ratio'),
                'price_to_book': fundamentals.get('price_to_book'),
                'price_to_sales': fundamentals.get('price_to_sales'),
                'debt_to_equity': fundamentals.get('debt_to_equity'),
                'return_on_equity': fundamentals.get('return_on_equity'),
                'return_on_assets': fundamentals.get('return_on_assets'),
                'profit_margin': fundamentals.get('profit_margin'),
                'operating_margin': fundamentals.get('operating_margin'),
                'gross_margin': fundamentals.get('gross_margin'),
                'dividend_yield': fundamentals.get('dividend_yield'),
                'revenue_growth': fundamentals.get('revenue_growth'),
                'earnings_growth': fundamentals.get('earnings_growth'),
                'current_ratio': fundamentals.get('current_ratio'),
                'beta': fundamentals.get('beta'),
                'cash_per_share': fundamentals.get('cash_per_share'),
                'book_value_per_share': fundamentals.get('book_value_per_share'),
                'analyst_rating': fundamentals.get('analyst_rating'),
                'target_price': fundamentals.get('target_price')
            }])
            
            self.db_manager.insert_stock_data(fund_data, 'stock_fundamentals')
            
        except Exception as e:
            self.logger.warning(f"Error storing fundamental data for {symbol}: {e}")
    
    def get_portfolio_summary(self) -> Dict[str, Any]:
        """
        Get comprehensive portfolio summary
        
        Returns:
            Dictionary containing portfolio summary
        """
        try:
            # Get portfolio positions
            positions = self.db_manager.get_portfolio_positions(self.portfolio_id)
            
            if positions.empty:
                return {
                    'status': 'success',
                    'total_value': 0,
                    'cash_balance': 0,
                    'positions_count': 0,
                    'top_holdings': [],
                    'sector_allocation': {},
                    'performance_metrics': {}
                }
            
            # Calculate summary metrics
            total_positions_value = positions['position_value'].sum()
            unrealized_pnl = positions['unrealized_pnl'].sum()
            
            # Get top holdings
            top_holdings = positions.nlargest(5, 'position_value')[
                ['symbol', 'company_name', 'quantity', 'position_value', 'unrealized_pnl']
            ].to_dict('records')
            
            # Calculate sector allocation
            sector_allocation = positions.groupby('sector')['position_value'].sum().to_dict()
            
            # Get FrontAccounting balance
            fa_balance = self.fa_integrator.get_portfolio_balance_sheet()
            
            summary = {
                'status': 'success',
                'total_positions_value': round(total_positions_value, 2),
                'cash_balance': fa_balance.get('cash_balance', 0),
                'total_portfolio_value': round(total_positions_value + fa_balance.get('cash_balance', 0), 2),
                'unrealized_pnl': round(unrealized_pnl, 2),
                'positions_count': len(positions),
                'top_holdings': top_holdings,
                'sector_allocation': sector_allocation,
                'fa_sync_status': fa_balance['status']
            }
            
            return summary
            
        except Exception as e:
            self.logger.error(f"Error getting portfolio summary: {e}")
            return {
                'status': 'error',
                'message': str(e)
            }
    
    def run_daily_analysis(self) -> Dict[str, Any]:
        """
        Run daily portfolio analysis and generate recommendations
        
        Returns:
            Dictionary containing analysis results
        """
        try:
            self.logger.info("Starting daily portfolio analysis")
            
            results = {
                'date': datetime.now().date(),
                'analysis_completed': 0,
                'recommendations': [],
                'portfolio_update': {},
                'errors': []
            }
            
            # Update current positions with latest prices
            positions = self.db_manager.get_portfolio_positions(self.portfolio_id)
            
            if not positions.empty:
                for _, position in positions.iterrows():
                    try:
                        symbol = position['symbol']
                        
                        # Get latest price
                        stock_data = self.data_fetcher.get_stock_data(symbol, period='1d', include_fundamentals=False)
                        
                        if not stock_data['price_data'].empty:
                            current_price = float(stock_data['price_data']['close'].iloc[-1])
                            
                            # Update position value and P&L
                            # This would normally update the database
                            self.logger.info(f"Updated {symbol} price to ${current_price:.2f}")
                            
                    except Exception as e:
                        results['errors'].append(f"Error updating {symbol}: {str(e)}")
            
            # Get new recommendations
            recommendations = self.get_portfolio_recommendations(max_recommendations=10)
            results['recommendations'] = recommendations
            results['analysis_completed'] = len(recommendations)
            
            # Update portfolio valuation in FrontAccounting
            if not positions.empty:
                portfolio_data = positions.to_dict('records')
                fa_update = self.fa_integrator.update_portfolio_valuation(portfolio_data)
                results['portfolio_update'] = fa_update
            
            self.logger.info(f"Daily analysis completed: {results['analysis_completed']} stocks analyzed")
            
            return results
            
        except Exception as e:
            self.logger.error(f"Error in daily analysis: {e}")
            return {
                'date': datetime.now().date(),
                'analysis_completed': 0,
                'recommendations': [],
                'portfolio_update': {},
                'errors': [str(e)]
            }
